# Дисклеймер
## В данном разделе указан один из возможных способов модификации робота. Данный раздел подразумевает самостоятельную работу в рамках обучения: отладку кода и установку камеры в любое подходящее место по вашему вкусу.

Для улучшения робота предлагаем добавить ему функцию стрельбы по мишеням. Для этого в его конструкцию стоит добавить:
|Наименование компонента|Примерная стоимость, руб.|
|---|:---:|
|[Камера для Raspberry Pi 4](https://www.ozon.ru/product/kamera-dlya-raspberry-pi-5mpx-asia-version-v1-3-502773940/?at=99tr412rMUzpqJGPHN71YBnf5WkrjEhNpVPJ0sLjYXO1&keywords=Камера+для+Raspberry+Pi+4)|683|
|[Сервопривод](https://www.ozon.ru/product/servoprivod-mg996r-servo-4-8-6-v-1636828834/?at=46tR4olRmIWqlkqoSgrLk02FEBO731t70LyRvcLzpEPW&keywords=сервопривод)|681|
|[Канцелярские резинки (небольшие)](https://www.ozon.ru/product/rezinki-kantselyarskie-bankovskie-40-mm-100-gramm-m-upak-1966832750/?at=vQtrwXAr2Uzlm1yofzMyvnJT1oExRZCBPN69vFxA2rZX&keywords=канцелярские+резинки+небольшие)|135|
|Итого|1499|

Как видно из рисунков, на корпусе появилась камера для Raspberry Pi 4, рядом с ней можно установить некую опору (уголок, стойка - не важно), сервопривод, который будет находиться за этой опорой, управлять им можно как от ESP32, так и от Raspberry Pi 4. В совокупности система __сервопривод + резинка + опора__ образуют "резинкомёт" (аналог рогатки). 

Логика конструкции максимально проста: программно задаются повороты головки сервопривода на равные углы в зависимости от количества зарядов. Количество зарядов определяется количеством лучей на креплении к сервоприводу.
Примерная схема "резинкомёта":

![](https://github.com/WWnotLL/ROS2_tutorial_305/blob/main/изображения%20к%20тексту/Схема%20резинкомета.png)

Примерный код для реализации такого механизма:
```
#include <Servo.h>  // Подключаем библиотеку для работы с сервоприводом

Servo myServo;  // Создаем объект сервопривода
int currentAngle = 0;  // Текущий угол сервопривода (начальное положение - 0°)
bool spacePressed = false;  // Флаг нажатия пробела

void setup() {
  Serial.begin(9600);  // Инициализация Serial-порта
  myServo.attach(9);  // Подключаем сервопривод к пину 9
  myServo.write(currentAngle);  // Устанавливаем начальный угол
  Serial.println("Нажмите пробел в Serial-мониторе для поворота сервопривода.");
}

void loop() {
  // Проверяем, есть ли данные в Serial
  if (Serial.available() > 0) {
    char input = Serial.read();  // Читаем введенный символ

    // Если нажат пробел (ASCII-код 32)
    if (input == ' ') {
      spacePressed = true;  // Устанавливаем флаг нажатия пробела
      Serial.println("Пробел нажат. Поворачиваем сервопривод...");
    }
  }

  // Если пробел был нажат
  if (spacePressed) {
    // Если сервопривод еще не достиг максимума (180°)
    if (currentAngle < 180) {
      currentAngle += 45;  // Увеличиваем угол на 45°
      if (currentAngle > 180) {
        currentAngle = 180;  // Ограничиваем максимум 180°
      }
      myServo.write(currentAngle);  // Поворачиваем сервопривод
      Serial.print("Угол сервопривода: ");
      Serial.println(currentAngle);
      delay(500);  // Задержка для плавности
    } 
    // Если сервопривод достиг максимума
    else {
      currentAngle = 0;  // Возвращаем в 0°
      myServo.write(currentAngle);
      Serial.println("Сервопривод вернулся в 0°");
      spacePressed = false;  // Сбрасываем флаг
    }
  }
}
```
