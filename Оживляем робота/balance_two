
// Timers library
#include <time.h>  // Подключение библиотеки для работы с временем (хотя в коде не используется)

// Connections:
// Encoder on LEFT wheel:
const byte encoder0pinA_LEFT = 13; // Пин A энкодера (левый двигатель) - подключен к пину прерывания
const byte encoder0pinB_LEFT = 12; // Пин B энкодера (левый двигатель)

// LEFT encoder variables:
byte encoder0PinALast_LEFT; // Предыдущее состояние пина A энкодера
boolean Direction_LEFT;     // Направление вращения (true/false)
int duration_LEFT = true;   // Счетчик импульсов энкодера (возможно, должно быть int = 0)
void wheelSpeed_LEFT();     // Прототип функции обработки прерывания энкодера

// Logger time
long start_time = 0;        // Метка времени начала работы для логгирования

// Static adjustments for engines imperfection
//// main cycle operation time
const int cycle_time = 500; // Время основного цикла в миллисекундах

void setup()
{
  pinMode(encoder0pinB_LEFT, INPUT); // Настройка пина B энкодера как вход

  // start serial port:
  Serial.begin(115200); // Инициализация последовательного порта для вывода данных

  // Initialize encoders
  attachInterrupt(encoder0pinA_LEFT, wheelSpeed_LEFT, CHANGE); // Настройка прерывания по изменению сигнала на пине A энкодера

  // create a start time mark
  start_time = millis(); // Запись текущего времени как времени начала работы

  Serial.println("Hi!"); // Тестовое сообщение о запуске
}

void loop()
{
  // Вывод количества импульсов с левого энкодера
  Serial.print("Duration left: ");
  Serial.println(duration_LEFT);

  // convert velocity from odometer pulses to meters per second
  float frequency = 1000 / cycle_time; // Расчет частоты циклов (но переменная не используется)

  // duration_LEFT / 470 * 2 * pi * (1000 / cycle_time)
  // Здесь должен быть расчет скорости, но формула закомментирована

  // main cycle delay
  delay(cycle_time); // Пауза перед следующим циклом
}

// Функция обработки прерывания энкодера левого колеса
void wheelSpeed_LEFT()
{
  int Lstate_LEFT = digitalRead(encoder0pinA_LEFT); // Текущее состояние пина A
  
  // Обработка переднего фронта импульса (LOW -> HIGH переход)
  if ((encoder0PinALast_LEFT == LOW) && Lstate_LEFT == HIGH)
  {
    int val = digitalRead(encoder0pinB_LEFT); // Чтение состояния пина B
    if (val == LOW && Direction_LEFT)
    {
      Direction_LEFT = false; // Изменение направления на обратное
    }
    else if (val == HIGH && !Direction_LEFT)
    {
      Direction_LEFT = true;  // Изменение направления на прямое
    }
  }
  // Обработка заднего фронта импульса (HIGH -> LOW переход)
  else if ((encoder0PinALast_LEFT == HIGH) && Lstate_LEFT == LOW)
  {
    int val = digitalRead(encoder0pinB_LEFT); // Чтение состояния пина B
    if (val == HIGH && Direction_LEFT)
    {
      Direction_LEFT = false; // Изменение направления на обратное
    }
    else if (val == LOW && !Direction_LEFT)
    {
      Direction_LEFT = true;  // Изменение направления на прямое
    }
  }
  
  encoder0PinALast_LEFT = Lstate_LEFT; // Сохранение текущего состояния для следующего вызова
  
  // Изменение счетчика импульсов в зависимости от направления
  if (!Direction_LEFT) duration_LEFT++; // Увеличение счетчика при обратном направлении
  else duration_LEFT--;                 // Уменьшение счетчика при прямом направлении
}
